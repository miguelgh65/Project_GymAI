# Archivo: docker-compose.yml (CORREGIDO - Montando raíz en /app)

# version: '3.8' # Opcional, obsoleto en Compose V2+

services:
  gym-postgres:
    image: postgres:latest # O una versión específica
    container_name: gym-postgres
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Asegúrate que la ruta a init-db.sql sea correcta si lo usas
      # Ahora que montamos '.' en /app, la ruta dentro del contenedor será /app/back_end/gym/init-db.sql
      - ./back_end/gym/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql # Ruta local -> Ruta dentro del contenedor de postgres
    ports:
      - "${DB_PORT}:5432"
    restart: unless-stopped
    networks:
      - gymnet

  gym-fastapi-backend:
    container_name: gym-fastapi-backend
    build:
      context: .
      # Asume que tu Dockerfile para el backend se llama 'Dockerfile' y está en la raíz
      dockerfile: Dockerfile
    env_file:
      - .env # Carga el .env global
    environment:
      # Pasar rutas SSL como variables de entorno para start.sh/uvicorn
      # Las rutas DENTRO del contenedor ahora son relativas a /app
      - SSL_KEY_PATH=${SSL_KEY_PATH_IN_CONTAINER}   # Debería ser /app/certs/... en .env
      - SSL_CERT_PATH=${SSL_CERT_PATH_IN_CONTAINER} # Debería ser /app/certs/... en .env
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      # Establecer PYTHONPATH a /app para ayudar con las importaciones desde la raíz montada
      - PYTHONPATH=/app
    volumes:
      # <<< VOLUMEN PRINCIPAL CORREGIDO >>>
      # Montar toda la raíz del proyecto local en /app dentro del contenedor
      - .:/app
      # Excluir node_modules si estuviera en la raíz (poco probable para backend)
      # - /app/node_modules 
      # <<< Montar certificados en /app/certs >>>
      # Asume que tienes una carpeta ./certs local con los .pem
      - ./certs:/app/certs:ro
      # start.sh ya está incluido porque montamos '.', no hace falta montarlo de nuevo
      # - ./start.sh:/app/start.sh
    ports:
      - "5050:5050"
    depends_on:
      - gym-postgres
    restart: unless-stopped
    # <<< Directorio de Trabajo DENTRO del contenedor >>>
    working_dir: /app
    # Ejecuta start.sh que ahora está en /app/start.sh
    command: sh -c "chmod +x /app/start.sh && /app/start.sh"
    networks:
      - gymnet

  gym-react-frontend:
    container_name: gym-react-frontend
    build:
      # Usar la carpeta correcta y asumir Dockerfile dentro
      context: ./front_end_react
      dockerfile: Dockerfile
    ports:
      # Exponer puertos para Nginx (HTTP y HTTPS)
      - "80:80"
      - "443:443"
    volumes:
      # Montar código fuente si estás en modo desarrollo
      - ./front_end_react:/app
      - /app/node_modules
      # Montar certificados también para Nginx (en /certs dentro del contenedor frontend)
      - ./certs:/certs:ro
      # Montar configuración de Nginx
      # Asume que tienes nginx.conf en la raíz del proyecto frontend
      - ./front_end_react/nginx.conf:/etc/nginx/conf.d/default.conf:ro
    environment:
      # Variables REACT_APP_* que necesite tu aplicación
      # Asegúrate que la URL base de la API apunte correctamente a donde expone el backend
      # Si accedes desde el navegador, debería ser https://localhost:5050 (o tu dominio)
      # O si Nginx hace proxy a /api, podría ser solo /api o https://localhost (puerto 443)
      - REACT_APP_API_BASE_URL=${REACT_APP_API_BASE_URL} 
      - REACT_APP_PROJECT_NAME=${REACT_APP_PROJECT_NAME}
      - REACT_APP_GOOGLE_CLIENT_ID=${REACT_APP_GOOGLE_CLIENT_ID}
      # ... etc ...
    restart: unless-stopped
    networks:
      - gymnet

networks:
  gymnet:
    driver: bridge

volumes:
  postgres_data:
    # driver: local # Opcional