import os
import json
import logging
import re
from typing import Dict, Any, List, Optional
import datetime

# Configuración de logging
logger = logging.getLogger("fitness_agent")

# Importar decorador traceable si está disponible
try:
    from fitness_agent.agent.nodes.router_node import traceable
except ImportError:
    # Simple decorator fallback
    def traceable(*args, **kwargs):
        def decorator(func):
            return func
        return decorator

# Importaciones específicas del proyecto
from fitness_agent.agent.core.state import AgentState
from fitness_agent.agent.utils.prompt_utils import get_formatted_prompt
from fitness_agent.agent.utils.llm_utils import get_llm, format_llm_response

# Importar herramientas directamente 
import psycopg2
from config import DB_CONFIG  # Importar configuración directamente

# Patrones para extraer nombres de ejercicios comunes
EXERCISE_PATTERNS = [
    r'press\s+banca',
    r'dominadas',
    r'sentadillas?',
    r'peso\s+muerto',
    r'prensa',
    r'curl\s+de\s+biceps',
    r'triceps',
    r'press\s+militar',
    r'press\s+frances',
    r'elevaciones\s+laterales?',
    r'remo',
    r'jalon',
    r'contractor\s+pecho',
    r'extension\s+de\s+piernas?'
]

@traceable(run_type="tool")
def extract_exercise_name(message: str) -> Optional[str]:
    """
    Extrae el nombre de un ejercicio del mensaje del usuario.
    
    Args:
        message: Mensaje del usuario
        
    Returns:
        str or None: Nombre del ejercicio o None si no se encontró
    """
    # Primero buscar patrones específicos de ejercicio
    message = message.lower()
    
    for pattern in EXERCISE_PATTERNS:
        match = re.search(pattern, message)
        if match:
            return match.group(0)
    
    # Buscar patrones como "ejercicio X" o "últimos X ejercicios de Y"
    exercise_match = re.search(r'ejercicios?\s+de\s+([a-záéíóúñ\s]+)', message)
    if exercise_match:
        return exercise_match.group(1).strip()
    
    # Buscar patrones como "mostrar X" o "últimos X"
    exercise_match = re.search(r'(ultimos?|recientes?)\s+\d+\s+([a-záéíóúñ\s]+)', message)
    if exercise_match:
        return exercise_match.group(2).strip()
    
    return None

def detect_intent_type(message: str) -> str:
    """
    Detecta el tipo específico de intención relacionada con progreso.
    
    Args:
        message: Mensaje del usuario
        
    Returns:
        str: Tipo de intención ('history', 'progression', 'recommendation')
    """
    message = message.lower()
    
    # Patrones para recomendaciones
    if any(pattern in message for pattern in ['recomienda', 'recomendación', 'sugerir', 'sugerencia', 
                                             'aumentar', 'subir', 'debo', 'cuánto debo']):
        return 'recommendation'
    
    # Patrones para progresión
    if any(pattern in message for pattern in ['progres', 'evolución', 'mejora', 'avance', 
                                             'estadística', 'análisis', 'tendencia']):
        return 'progression'
    
    # Por defecto, historial
    return 'history'

# Función directa para obtener ejercicios recientes
def get_recent_exercises_direct(user_id: str, days: int = 90, exercise_name: str = None) -> List[Dict]:
    """
    Obtiene los ejercicios recientes del usuario directamente de la base de datos.
    
    Args:
        user_id: ID del usuario
        days: Número de días hacia atrás
        exercise_name: Nombre del ejercicio para filtrar (opcional)
        
    Returns:
        Lista de ejercicios en formato de diccionario
    """
    try:
        logger.info(f"Consultando ejercicios: user_id={user_id}, days={days}, exercise={exercise_name}")
        
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor()
        
        cutoff = datetime.datetime.now() - datetime.timedelta(days=days)
        cutoff_str = cutoff.strftime('%Y-%m-%d %H:%M:%S')
        
        # Ver si user_id es un entero
        try:
            user_uuid = int(user_id)
            has_uuid = True
            logger.info(f"User ID convertido a entero: {user_uuid}")
        except ValueError:
            user_uuid = None
            has_uuid = False
            logger.info(f"User ID no es un entero: {user_id}")
        
        # Construir consulta con o sin filtro de ejercicio
        params = []
        
        query = """
            SELECT fecha, ejercicio, repeticiones, duracion
            FROM ejercicios
            WHERE fecha >= %s
        """
        params.append(cutoff_str)
        
        # Añadir condición de usuario
        if has_uuid:
            query += " AND (user_id = %s OR user_uuid = %s)"
            params.extend([user_id, user_uuid])
        else:
            query += " AND user_id = %s"
            params.append(user_id)
        
        # Añadir filtro de ejercicio si se proporciona
        if exercise_name:
            query += " AND LOWER(ejercicio) LIKE LOWER(%s)"
            params.append(f"%{exercise_name}%")  # Usar LIKE para búsqueda más flexible
        
        # Ordenar por fecha descendente
        query += " ORDER BY fecha DESC"
        
        logger.info(f"Query: {query}")
        logger.info(f"Params: {params}")
        
        cur.execute(query, params)
        rows = cur.fetchall()
        
        logger.info(f"Rows encontradas: {len(rows)}")
        
        # Procesar resultados
        results = []
        for row in rows:
            fecha = row[0]
            ejercicio = row[1]
            repeticiones = row[2]
            duracion = row[3]
            
            entry = {
                "fecha": fecha.strftime('%Y-%m-%d %H:%M:%S') if hasattr(fecha, 'strftime') else str(fecha),
                "ejercicio": ejercicio
            }
            
            # Procesar campo de repeticiones
            if repeticiones:
                if isinstance(repeticiones, str):
                    try:
                        series = json.loads(repeticiones)
                        entry["series"] = series
                    except json.JSONDecodeError:
                        entry["series"] = repeticiones
                else:
                    entry["series"] = repeticiones
            
            # Añadir duración si está disponible
            if duracion:
                entry["duracion"] = duracion
                
            results.append(entry)
        
        cur.close()
        conn.close()
        
        return results
    
    except Exception as e:
        logger.error(f"Error obteniendo ejercicios recientes: {e}")
        return []

# Función para preparar datos para el LLM
def prepare_exercise_data_for_llm(exercises: List[Dict], exercise_name: str, intent_type: str) -> Dict:
    """
    Prepara los datos de ejercicios para enviarlos al LLM.
    
    Args:
        exercises: Lista de ejercicios
        exercise_name: Nombre del ejercicio
        intent_type: Tipo de intención
        
    Returns:
        Dict: Datos preparados para análisis por LLM
    """
    if not exercises:
        return {
            "exercise_name": exercise_name,
            "total_sessions": 0,
            "sessions": []
        }
    
    # Ordenar por fecha (más antiguo primero)
    sorted_exercises = sorted(exercises, key=lambda x: x.get('fecha', ''))
    
    # Extraer y normalizar datos de series
    prepared_sessions = []
    
    for exercise in sorted_exercises:
        if 'series' in exercise and exercise['series']:
            series = exercise['series']
            
            # Normalizar series a formato de lista de diccionarios
            normalized_series = []
            
            # Si es string, intentar convertirlo a JSON
            if isinstance(series, str):
                try:
                    series = json.loads(series)
                except json.JSONDecodeError:
                    continue
            
            # Asegurar que series es una lista
            if isinstance(series, list):
                for serie in series:
                    if isinstance(serie, dict):
                        reps = serie.get('repeticiones', 0)
                        peso = serie.get('peso', 0)
                        
                        if isinstance(reps, str):
                            try:
                                reps = int(reps)
                            except ValueError:
                                reps = 0
                        
                        if isinstance(peso, str):
                            try:
                                peso = float(peso)
                            except ValueError:
                                peso = 0
                        
                        normalized_series.append({
                            'repeticiones': reps,
                            'peso': peso
                        })
            
            if normalized_series:
                # Calcular valores para esta sesión
                session_max_weight = max([s.get('peso', 0) for s in normalized_series])
                session_volume = sum([s.get('repeticiones', 0) * s.get('peso', 0) for s in normalized_series])
                session_total_reps = sum([s.get('repeticiones', 0) for s in normalized_series])
                
                prepared_sessions.append({
                    'fecha': exercise.get('fecha', ''),
                    'series': normalized_series,
                    'max_peso': session_max_weight,
                    'volumen': session_volume,
                    'repeticiones_totales': session_total_reps
                })
    
    # Calcular estadísticas básicas para ayudar al LLM
    stats = {
        "exercise_name": exercise_name,
        "total_sessions": len(prepared_sessions),
        "intent_type": intent_type
    }
    
    if prepared_sessions:
        stats["first_session_date"] = prepared_sessions[0]['fecha']
        stats["latest_session_date"] = prepared_sessions[-1]['fecha']
        stats["sessions"] = prepared_sessions
        
        # Extraer pesos y volúmenes para análisis de tendencias
        weights = [s['max_peso'] for s in prepared_sessions]
        volumes = [s['volumen'] for s in prepared_sessions]
        
        if weights:
            stats["initial_max_weight"] = weights[0]
            stats["latest_max_weight"] = weights[-1]
            stats["highest_max_weight"] = max(weights)
            
            # Calcular cambio porcentual básico
            if weights[0] > 0:
                weight_change_percent = ((weights[-1] - weights[0]) / weights[0]) * 100
                stats["weight_change_percent"] = round(weight_change_percent, 1)
        
        if volumes:
            stats["highest_volume"] = max(volumes)
            stats["average_volume"] = sum(volumes) / len(volumes)
    
    return stats

@traceable(run_type="chain")
def progress_node(state: AgentState) -> Dict[str, Any]:
    """
    Nodo especializado en consultas relacionadas con progreso y estadísticas de entrenamiento.
    
    Args:
        state: Estado actual del agente
        
    Returns:
        Estado actualizado con la respuesta del nodo
    """
    try:
        # Obtener datos del mensaje
        messages = state["messages"]
        user_id = state["user_id"]
        user_message = messages[-1]["content"]  # Último mensaje del usuario
        
        logger.info(f"Progress node procesando mensaje: '{user_message[:50]}...' para user_id={user_id}")
        
        # Determinar tipo específico de intención
        intent_type = detect_intent_type(user_message)
        logger.info(f"Tipo de intención detectado: {intent_type}")
        
        # Extraer nombre del ejercicio del mensaje
        exercise_name = extract_exercise_name(user_message)
        logger.info(f"Nombre de ejercicio extraído: '{exercise_name}'")
        
        # Si no se pudo extraer un ejercicio, solicitar clarificación
        if not exercise_name:
            return {
                "messages": [{
                    "role": "assistant", 
                    "content": "Por favor, indica específicamente qué ejercicio te interesa analizar. "
                               "Por ejemplo: 'muestra mi progreso en press banca' o 'cuánto debo subir en sentadillas'"
                }]
            }
        
        # Extraer límite de días o número de ejercicios
        limit_match = re.search(r'(\d+)\s+(dias|días|ultimos|últimos|recientes)', user_message, re.IGNORECASE)
        limit = 10
        days = 90  # Por defecto, buscar en los últimos 90 días
        
        if limit_match:
            try:
                limit = int(limit_match.group(1))
                # Asegurar valores razonables
                limit = max(1, min(limit, 50))
            except ValueError:
                pass
        
        logger.info(f"Límite establecido: {limit} ejercicios, {days} días")
        
        # Obtener ejercicios directamente de la base de datos
        exercises = get_recent_exercises_direct(user_id, days=days, exercise_name=exercise_name)
        
        # Verificar si hay datos
        if not exercises:
            return {
                "messages": [{
                    "role": "assistant", 
                    "content": f"No encontré ejercicios de {exercise_name} en tu historial. "
                               "Asegúrate de haber registrado correctamente tus entrenamientos."
                }]
            }
        
        # Limitar resultados para historial (solo para la visualización)
        limited_exercises = exercises[:limit]
        
        logger.info(f"Obtenidos {len(exercises)} ejercicios, mostrando {len(limited_exercises)}")
        
        # Preparar prompt para el LLM según el tipo de intención
        if intent_type == 'history':
            # Formatear resultados para mostrar historial
            
            # Extraer series para visualización
            formatted_history = "📊 *HISTORIAL DE EJERCICIOS* 📊\n\n"
            
            for i, exercise in enumerate(limited_exercises, 1):
                fecha = exercise.get('fecha', 'Sin fecha')
                ejercicio = exercise.get('ejercicio', 'Ejercicio desconocido')
                
                formatted_history += f"*Sesión {i}:* {fecha}\n"
                formatted_history += f"*Ejercicio:* {ejercicio}\n"
                
                # Procesar series
                if 'series' in exercise and exercise['series']:
                    series = exercise['series']
                    
                    # Si es string, intentar convertirlo a JSON
                    if isinstance(series, str):
                        try:
                            series = json.loads(series)
                        except json.JSONDecodeError:
                            series = [{"info": series}]
                    
                    # Procesar series como lista de diccionarios
                    if isinstance(series, list):
                        for j, serie in enumerate(series, 1):
                            if isinstance(serie, dict):
                                reps = serie.get('repeticiones', 'N/A')
                                peso = serie.get('peso', 'N/A')
                                formatted_history += f"  • Serie {j}: {reps} reps x {peso}kg\n"
                            else:
                                formatted_history += f"  • Serie {j}: {serie}\n"
                    else:
                        formatted_history += f"  • Series: {series}\n"
                
                # Procesar duración
                if 'duracion' in exercise and exercise['duracion']:
                    formatted_history += f"*Duración:* {exercise['duracion']} minutos\n"
                
                formatted_history += "\n"
            
            formatted_history += "💪 *¡SIGUE ASÍ, LIGHTWEIGHT BABY!* 💪"
            
            return {
                "messages": [{
                    "role": "assistant", 
                    "content": formatted_history
                }]
            }
        
        # Para progresión y recomendaciones, usar el LLM
        # Preparar datos para el LLM
        prepared_data = prepare_exercise_data_for_llm(exercises, exercise_name, intent_type)
        
        # Crear contexto para el LLM
        context = json.dumps(prepared_data, indent=2)
        
        # Seleccionar el prompt adecuado según la intención
        if intent_type == 'progression':
            prompt_template = """
Eres un entrenador personal especializado en analizar el progreso en ejercicios de fuerza. 
Necesito que analices los datos de entrenamiento de un usuario para el ejercicio {exercise_name}.

DATOS DEL USUARIO:
{context}

Por favor, proporciona un análisis detallado del progreso del usuario en este ejercicio que incluya:
1. Una evaluación general de su progresión (ha mejorado, se ha estancado, ha retrocedido)
2. Análisis de la evolución de peso y repeticiones a lo largo del tiempo
3. Identificación de tendencias o patrones (mejora constante, mesetas, regresiones, etc.)
4. Valoración de la consistencia y frecuencia de entrenamiento

IMPORTANTE:
- Sé específico con los números y porcentajes de mejora
- Considera la progresión tanto en peso máximo como en volumen total
- Señala si hay estancamientos y cuánto tiempo llevan
- Usa un tono motivador pero realista, como un entrenador personal profesional
- Añade alguna frase motivadora al estilo de Ronnie Coleman al final (LIGHTWEIGHT BABY, etc.)

Formatea tu respuesta con Markdown y emoticonos relevantes para hacerla más visual.
            """
        elif intent_type == 'recommendation':
            prompt_template = """
Eres un entrenador personal especializado en programación de fuerza. 
Necesito que analices los datos de entrenamiento de un usuario para el ejercicio {exercise_name} y proporciones recomendaciones.

DATOS DEL USUARIO:
{context}

Por favor, proporciona recomendaciones específicas para progresar en este ejercicio:
1. Sugerencias concretas para las próximas series (repeticiones y peso)
2. Estrategia de progresión recomendada (aumentar peso, aumentar repeticiones, etc.)
3. Consejos técnicos relevantes para este ejercicio específico
4. Patrones de descanso y recuperación recomendados

IMPORTANTE:
- Sugiere números concretos para las próximas series basados en su historial
- Considera su patrón de progresión actual (rápido, lento, estancado)
- Explica por qué recomiendas estos cambios específicos
- Adapta tus recomendaciones al nivel aparente del usuario
- Añade alguna frase motivadora al estilo de Ronnie Coleman al final (LIGHTWEIGHT BABY, etc.)

Formatea tu respuesta con Markdown y emoticonos relevantes para hacerla más visual.
            """
        else:
            # Fallback a history (aunque esto no debería ocurrir por la lógica anterior)
            return {
                "messages": [{
                    "role": "assistant", 
                    "content": f"No pude procesar correctamente tu consulta sobre {exercise_name}. "
                               "Por favor, intenta ser más específico."
                }]
            }
        
        # Formatear el prompt
        prompt = prompt_template.format(
            exercise_name=exercise_name,
            context=context
        )
        
        # Generar respuesta usando el LLM
        llm = get_llm()
        
        # Preparar los mensajes para el LLM
        messages_for_llm = [
            {"role": "system", "content": prompt},
            {"role": "user", "content": user_message}
        ]
        
        # Llamar al LLM
        response = llm.invoke(messages_for_llm)
        content = format_llm_response(response.content)
        
        # Crear mensaje de respuesta
        response_message = {
            "role": "assistant",
            "content": content
        }
        
        # Retornar respuesta
        return {"messages": [response_message]}
    
    except Exception as e:
        logger.error(f"Error en progress_node: {e}")
        
        # Mensaje de error
        error_message = {
            "role": "assistant",
            "content": f"Lo siento, ocurrió un error al procesar tu consulta sobre progreso. Por favor, inténtalo de nuevo.\n\n¡Sigue esforzándote! 💪"
        }
        
        return {"messages": [error_message]}